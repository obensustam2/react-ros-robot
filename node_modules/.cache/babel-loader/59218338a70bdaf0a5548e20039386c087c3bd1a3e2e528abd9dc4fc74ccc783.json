{"ast":null,"code":"'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}","map":{"version":3,"names":["UPPER32","Math","pow","warnedPrecision","warnPrecision","console","warn","decodeUint64LE","bytes","byteLen","byteLength","offset","byteOffset","arrLen","buffer","slice","uint32View","Uint32Array","arr","Array","i","si","lo","hi","decodeInt64LE","int32View","Int32Array","decodeNativeArray","ArrayType","nativeArrayTypes","Uint8Array","Uint16Array","Int8Array","Int16Array","Float32Array","Float64Array","conversionArrayTypes","cborTypedArrayTagger","data","tag","arrayType","module","exports"],"sources":["/home/oben-n/react-ros-robot/node_modules/roslib/src/util/cborTypedArrayTags.js"],"sourcesContent":["'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\n\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}